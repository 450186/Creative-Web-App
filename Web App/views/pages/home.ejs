<%- include("../partials/header") %>

<p style="text-align: center;">Welcome to TravLR, your ultimate travel companion!</p>
<% if (typeof errorMessage !== 'undefined' || typeof successMessage !== 'undefined') { %>
    <div id="alerts">
        <% if (typeof errorMessage !== 'undefined') { %>
            <p id="errorMessage" style="text-align: center;"><%= errorMessage %></p>
        <% } %>
        <% if (typeof successMessage !== 'undefined') { %>
            <p id="successMessage" style="text-align: center;"><%= successMessage %></p>
        <% } %>
    </div>
<% } %>
<p id="errorMessage"></p>
<script>
    let alertDiv = document.getElementById("alerts")
    if(alertDiv) {
        setTimeout(() => {
            alertDiv.classList.add("fade-out")
        }, 3000)
        setTimeout(() => {
            alertDiv.style.display = "none"
        }, 4000)
    }
</script>
<form action="/search-location" method="GET" id="location-search">
    <div id="searchbar">
        <input type="text" name="query" placeholder="Search for a City..." required>
        <button type="submit" aria-label="Search">
            <i class="fa-solid fa-magnifying-glass fa-rotate-90"></i>
        </button>
    </div>
</form>
<div id="map-container">
    <div id="map-wrap">
        <div id="map"></div>
        <button class="map-fab" id="toggle-dart" type="button">Dart Mode: OFF</button>
    </div>
    <div id="location-data" data-wishlist="<%= JSON.stringify(wishList) %>" data-locations="<%= JSON.stringify(locations) %>"></div>
    <div id="key-div">
        <h3>Key:</h3>
        <div class="key">
            <div id="green-div">
                <div class="key-left">
                    <img class="pins" src="/assets/GreenPin.png" alt="Green Pin">
                    <p>Visited</p>
                </div>
                <div class="key-right">
                    <input class="checkboxes" checked type="checkbox" id="green-check">
                    <label id="green-label" for="green-check">{greenLabel}</label>
                </div>            
            </div>
        </div>
            <div class="key">
                <div id="gold-div">
                    <div class="key-left">
                        <img class="pins" src="/assets/GoldPin.png" alt="Gold Pin">
                        <p>WishList</p>
                    </div>
                <div class="key-right">
                    <input class="checkboxes" checked type="checkbox" id="gold-check">
                    <label id="gold-label" for="gold-check">{goldLabel}</label>
                </div>
            </div>
        </div>
    </div>
</div>

<script>

    let isAiming = false;     // finger/mouse is dragging
    let didThrow = false;     // we actually threw a dart (not just a tap)

    var map = L.map('map').setView([20, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Load GeoJSON data for land detection
    let WorldGeo = null;
    fetch('/assets/Geojson.json')
    .then(res => res.json())
    .then(data => {
        WorldGeo = L.geoJSON(data);
        console.log("GeoJSON data loaded");
    })
    .catch(err => console.error("Error loading GeoJSON data:", err));

    let ignoreClicksUntil = 0;

    map.on("click", function (click) {
        if (isAiming || dartInFlight) return;
        if(Date.now() < ignoreClicksUntil) return;

        if(!WorldGeo) {
            errorMessage.innerText = "GeoJSON data not loaded yet. Please try again in a moment.";
            setTimeout(() => {
                errorMessage.classList.add("fade-out");
            }, 3000);
            setTimeout(() => {
                errorMessage.innerText = "";
            }, 4000);
            return;
        }

        const latitude = click.latlng.lat
        const longitude = click.latlng.lng

        const point = [longitude, latitude]; // GeoJSON format

        // Geo JSON information taken from https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json
        const Geo = leafletPip.pointInLayer(point, WorldGeo);

        if(Geo.length === 0) {
            errorMessage.innerText = "Please select a location on land, not in the ocean.";
            setTimeout(() => {
                errorMessage.classList.add("fade-out");
            }, 3000);
            setTimeout(() => {
                errorMessage.innerText = "";
            }, 4000);
            return;
        }

        window.location.href = `/location?latitude=${latitude}&longitude=${longitude}`
    })

    const GreenPin = L.icon({
        iconUrl: "/assets/GreenPin.png",
        iconSize: [25, 30],
        iconAnchor: [17, 30],
        popupAnchor: [-5, -34]
    })
    const GoldPin = L.icon({
        iconUrl: "/assets/GoldPin.png",
        iconSize: [25, 30],
        iconAnchor: [17, 30],
        popupAnchor: [-5, -34]   
    })

    //https://github.com/Digitalbrainstem/ejs-grammar/issues/78

    const locationData = document.getElementById("location-data")
    const Userlocations = JSON.parse(locationData.dataset.locations)
    const wishlistLocs= JSON.parse(locationData.dataset.wishlist)
    let greenCheck = document.getElementById("green-check")
    let goldCheck = document.getElementById("gold-check")
    let greenLabel = document.getElementById("green-label")
    let goldLabel = document.getElementById("gold-label")
    let errorMessage = document.getElementById("errorMessage")
    document.getElementById("green-div").onclick = () => greenCheck.click();
    document.getElementById("gold-div").onclick = () => goldCheck.click();


    let greenPins = []
    let goldPins = []

    Userlocations.forEach(location => {
        if(!location.longitude || !location.latitude) return
        const green = L.marker([location.latitude, location.longitude], {icon: GreenPin})
        .addTo(map)
        .bindPopup(`<strong>${location.city}</strong>
        <br>
        <em>${location.country}</em>
        <br>
        ${location.rating}⭐️`)
        greenPins.push(green)

        green.on('popupopen', function() {
            const element = green.getPopup().getElement();
            element.onclick= () => {
                window.location.href = `/location?latitude=${location.latitude}&longitude=${location.longitude}`;
            }
        });
    });

    wishlistLocs.forEach(wishlistLoc => {
        if(!wishlistLoc.longitude || !wishlistLoc.latitude) return
        const gold = L.marker([wishlistLoc.latitude, wishlistLoc.longitude], {icon: GoldPin})
        .addTo(map)
        .bindPopup(`<strong>${wishlistLoc.city}</strong>
        <br>
        <em>${wishlistLoc.country}</em>
        <br>`)
        goldPins.push(gold)
        gold.on('popupopen', function() {
            const element = gold.getPopup().getElement();
            element.onclick = () => {
                window.location.href = `/location?latitude=${wishlistLoc.latitude}&longitude=${wishlistLoc.longitude}`;
            }
        });
    })
    function updateGreens() {
        if(greenCheck.checked) {
            greenPins.forEach(m => m.addTo(map))
            greenLabel.textContent = "Hide"

        } else {
            greenPins.forEach(m => map.removeLayer(m))
            greenLabel.textContent = "Show"

        }
    }
        function updateGolds() {
        if(goldCheck.checked) {
            goldPins.forEach(m => m.addTo(map))
            goldLabel.textContent = "Hide"

        } else {
            goldPins.forEach(m => map.removeLayer(m))
            goldLabel.textContent = "Show"

        }
    }
    updateGreens()
    updateGolds()
    greenCheck.addEventListener("change", updateGreens)
    goldCheck.addEventListener("change", updateGolds)

    const DartIcon = L.icon({
    iconUrl: "/assets/dart-icon.png",
    iconSize: [32, 32],
    iconAnchor: [16, 16],
    });

    let dartMode = false;
    const toggleDartBtn = document.getElementById("toggle-dart");
    toggleDartBtn.addEventListener("click", () => {
        dartMode = !dartMode;
        toggleDartBtn.textContent = dartMode ? "Dart Mode: ON" : "Dart Mode: OFF";
    })

    //below is all from chatGPT with some modifications to fit my needs

    function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}

function degToRad(d) { return (d * Math.PI) / 180; }
function radToDeg(r) { return (r * 180) / Math.PI; }

// Destination point given start latlng, bearing degrees, distance meters
function destinationLatLng(start, bearingDeg, distanceM) {
  const R = 6371000; // earth radius meters
  const brng = degToRad(bearingDeg);

  const lat1 = degToRad(start.lat);
  const lon1 = degToRad(start.lng);

  const lat2 = Math.asin(
    Math.sin(lat1) * Math.cos(distanceM / R) +
    Math.cos(lat1) * Math.sin(distanceM / R) * Math.cos(brng)
  );

  const lon2 = lon1 + Math.atan2(
    Math.sin(brng) * Math.sin(distanceM / R) * Math.cos(lat1),
    Math.cos(distanceM / R) - Math.sin(lat1) * Math.sin(lat2)
  );

  let lng = ((radToDeg(lon2) + 540) % 360) - 180;
  return L.latLng(radToDeg(lat2), lng);
}

// Add a bit of randomness so darts don’t always land perfectly on the vector
function jitterBearingAndDistance(bearingDeg, distanceM) {
  const cone = clamp(distanceM / 15000, 5, 25); // degrees
  const bearingJitter = (Math.random() * 2 - 1) * cone;
  const distJitter = distanceM * (0.85 + Math.random() * 0.30);
  return { bearingDeg: bearingDeg + bearingJitter, distanceM: distJitter };
}


    // --- LAND CHECK helper (reuses your WorldGeo + leafletPip) ---
function isOnLand(latlng) {
  if (!WorldGeo) return true; // fail open while loading
  const point = [latlng.lng, latlng.lat];
  const geo = leafletPip.pointInLayer(point, WorldGeo);
  return geo.length > 0;
}

// Try to find a land endpoint by shrinking distance along same bearing
function findLandEnd(start, bearingDeg, distanceM) {
  let dist = distanceM;

  for (let i = 0; i < 8; i++) {
    const { bearingDeg: b2, distanceM: d2 } = jitterBearingAndDistance(bearingDeg, dist);
    const candidate = destinationLatLng(start, b2, d2);

    if (isOnLand(candidate)) return candidate;

    dist *= 0.75; // shrink and retry
  }

  // if all else fails, just return the last candidate-ish
  return destinationLatLng(start, bearingDeg, distanceM * 0.3);
}

// --- Hammer setup ---
const mapEl = document.getElementById("map");

// Use Manager so we can tune recognizers cleanly
const hammer = new Hammer.Manager(mapEl);
hammer.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL, threshold: 5 }));

// Prevent browser gestures
mapEl.style.touchAction = "none";

let dartMarker = null;
let dartInFlight = false;

let startPt = null;
let lastPt = null;

function disableMapInteractions() {
  map.dragging.disable();
  map.touchZoom.disable();
  map.doubleClickZoom.disable();
  map.scrollWheelZoom.disable();
  map.boxZoom.disable();
  map.keyboard.disable();
  if (map.tap) map.tap.disable();
}

function enableMapInteractions() {
  map.dragging.enable();
  map.touchZoom.enable();
  map.doubleClickZoom.enable();
  map.scrollWheelZoom.enable();
  map.boxZoom.enable();
  map.keyboard.enable();
  if (map.tap) map.tap.enable();
}

function metersPerPixel(lat) {
  // meters per pixel at given latitude and current zoom
  const zoom = map.getZoom();
  const earthCircumference = 40075016.686; // meters
  return (earthCircumference * Math.cos(lat * Math.PI / 180)) / Math.pow(2, zoom + 8);
}


hammer.on("panstart", (e) => {
    if(!dartMode) return;
    isAiming = true;
    didThrow = false;
  ignoreClicksUntil = Date.now() + 600;

  if (dartInFlight) return;

  disableMapInteractions();

  startPt = { x: e.center.x, y: e.center.y };
  lastPt = startPt;
});

hammer.on("panmove", (e) => {
  if (!dartMode || !startPt) return;
  lastPt = { x: e.center.x, y: e.center.y };

  // optional: draw an aim line here (later)
});

hammer.on("panend pancancel", (e) => {
  ignoreClicksUntil = Date.now() + 600;
  if(!dartMode) return;

  if (dartInFlight || !startPt || !lastPt) {
    startPt = null;
    lastPt = null;
    isAiming = false;
    enableMapInteractions();
    return;
  }

  const dx = lastPt.x - startPt.x;
  const dy = lastPt.y - startPt.y;
  const distPx = Math.hypot(dx, dy);

  // ignore tiny drags
  if (distPx < 35) {
    startPt = null;
    lastPt = null;
    isAiming = false;
    enableMapInteractions();
    return;
  }

  didThrow = true;

  // start from finger start point
  const startLatLng = containerPointToLatLngFromScreenPoint(startPt);

  // bearing (0=north)
  const angleRad = Math.atan2(-dy, dx);
  let bearing = (90 - (angleRad * 180 / Math.PI));
  bearing = (bearing + 360) % 360;

  // zoom-scaled distance
const zoom = map.getZoom();
const mpp = metersPerPixel(startLatLng.lat);

// Higher zoom → shorter throws (normalise around zoom 4–6 typically)
let zoomFactor = Math.pow(2, (10 - zoom));       // <- 6 is a nicer baseline than 12
zoomFactor = clamp(zoomFactor, 0.25, 8);        // <- stop extremes

const BASE_THROW = 120; // tweak this once

let distanceM = distPx * mpp * BASE_THROW * zoomFactor;

// Ease-out power curve (changes feel)
const ease = Math.sqrt(distPx / 100);
distanceM *= clamp(ease, 0.5, 2);

// FINAL clamp should be last
distanceM = clamp(distanceM, 2000, 1500000);

  const endLatLng = findLandEnd(startLatLng, bearing, distanceM);
  throwDart(startLatLng, endLatLng);

  startPt = null;
  lastPt = null;
  isAiming = false;
  enableMapInteractions();
});


// helper for container-point conversion if you use option 2
function containerPointToLatLngFromScreenPoint(pt) {
  const rect = mapEl.getBoundingClientRect();
  const x = pt.x - rect.left;
  const y = pt.y - rect.top;
  return map.containerPointToLatLng([x, y]);
}

// --- Dart throw animation ---
function throwDart(start, end) {
  dartInFlight = true;
  ignoreClicksUntil = Date.now() + 2000;

  if (!dartMarker) {
    dartMarker = L.marker(start, { icon: DartIcon, zIndexOffset: 2000 }).addTo(map);
  } else {
    dartMarker.setLatLng(start);
  }

  // (optional) keep view reasonable — DON'T fitBounds huge distances
  // Instead: pan a bit toward the end if it's off-screen
  if (!map.getBounds().pad(-0.15).contains(end)) {
    map.panTo(end, { animate: true, duration: 0.4 });
  }

  const durationMs = 700;
  dartMarker.slideTo(end, { duration: durationMs });

  dartMarker.once("moveend", async () => {
  dartInFlight = false;
  window.location.href = `/location?latitude=${end.lat}&longitude=${end.lng}`;
});

}


</script>

<%- include("../partials/footer") %>